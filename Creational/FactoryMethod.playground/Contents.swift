import Foundation

// ### Имя и тип
// - **Имя**: Фабричный метод (Factory Method)
// - **Тип**: Порождающий паттерн проектирования

// ### Задача
// Представим, что у нас есть приложение для создания различных типов документов. 
// Каждый тип документа требует различного рендеринга и обработки.
// Задача состоит в том, чтобы обеспечить гибкое создание объектов разных классов документов,
// при этом не привязываясь к конкретным классам этих документов.

// ### Решение
// Решение заключается в использовании фабричного метода,
// который позволяет делегировать создание объектов дочерним классам.
// Мы определяем абстрактный класс `DocumentCreator`, который объявляет фабричный метод `createDocument()`.
// Подклассы `DocumentCreator` будут реализовывать этот метод для создания конкретных типов документов.

// ### Результаты
// **Плюсы**:
// - Упрощает добавление новых типов в программу.
// - Изолирует код конструирования от использования.
// - Выполняет принцип открытости/закрытости (Open/Closed Principle),
//   так как клиентский код не нуждается в изменении при добавлении новых типов продуктов.

// **Минусы**:
// - Может привести к созданию большого количества классов, 
//   поскольку для каждого типа продукта требуется свой подкласс создателя.

// ### Код

// Абстрактный "класс" "Создатель", объявляющий фабричный метод.
// (Так как в свифт нет абстрактных классов, как в других языках,
// принято использовать протокол для его замены)
protocol DocumentCreator {
    func createDocument() -> Document
}

// Протокол для продуктов, которые будут создаваться
protocol Document {
    func render()
}

// Конкретные реализации продуктов
class TextDocument: Document {
    func render() {
        print("Rendering Text Document")
    }
}

class PDFDocument: Document {
    func render() {
        print("Rendering PDF Document")
    }
}

// Конкретные создатели для создания конкретных продуктов
class TextDocumentCreator: DocumentCreator {
    func createDocument() -> Document {
        return TextDocument()
    }
}

class PDFDocumentCreator: DocumentCreator {
    func createDocument() -> Document {
        return PDFDocument()
    }
}

// Использование фабричного метода
func clientCode(creator: DocumentCreator) {
    // В реальном приложении тип создателя может быть выбран в зависимости от конфигурации или окружения
    let document = creator.createDocument()
    document.render()
}

// Пример использования
let textCreator = TextDocumentCreator()
clientCode(creator: textCreator)

let pdfCreator = PDFDocumentCreator()
clientCode(creator: pdfCreator)

// В этом примере `DocumentCreator` является протоколом, который определяет фабричный метод `createDocument()`. 
// `TextDocumentCreator` и `PDFDocumentCreator` - это конкретные реализации этого протокола,
// каждая из которых создает свой тип документа.
// Функция `clientCode` демонстрирует, как клиентский код может использовать различные создатели,
// не зная о конкретных классах продуктов, которые они создают.
// Это позволяет программе быть гибкой и легко расширяемой за счет добавления новых типов документов.
